// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.19.6
// source: api/proto/device/v1/device.proto

package devicev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DeviceService_RegisterDevice_FullMethodName      = "/device.v1.DeviceService/RegisterDevice"
	DeviceService_UnregisterDevice_FullMethodName    = "/device.v1.DeviceService/UnregisterDevice"
	DeviceService_ListDevices_FullMethodName         = "/device.v1.DeviceService/ListDevices"
	DeviceService_GetDevice_FullMethodName           = "/device.v1.DeviceService/GetDevice"
	DeviceService_RequestDeviceAccess_FullMethodName = "/device.v1.DeviceService/RequestDeviceAccess"
	DeviceService_ReleaseDeviceAccess_FullMethodName = "/device.v1.DeviceService/ReleaseDeviceAccess"
	DeviceService_SubscribeToDevice_FullMethodName   = "/device.v1.DeviceService/SubscribeToDevice"
	DeviceService_DeviceChannel_FullMethodName       = "/device.v1.DeviceService/DeviceChannel"
	DeviceService_WatchDevices_FullMethodName        = "/device.v1.DeviceService/WatchDevices"
)

// DeviceServiceClient is the client API for DeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DeviceService provides device registration and access management
type DeviceServiceClient interface {
	// RegisterDevice registers a new device with the system
	RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error)
	// UnregisterDevice removes a device from the system
	UnregisterDevice(ctx context.Context, in *UnregisterDeviceRequest, opts ...grpc.CallOption) (*UnregisterDeviceResponse, error)
	// ListDevices returns all registered devices, optionally filtered by type
	ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error)
	// GetDevice returns details about a specific device
	GetDevice(ctx context.Context, in *GetDeviceRequest, opts ...grpc.CallOption) (*GetDeviceResponse, error)
	// RequestDeviceAccess requests access to a device
	RequestDeviceAccess(ctx context.Context, in *RequestDeviceAccessRequest, opts ...grpc.CallOption) (*RequestDeviceAccessResponse, error)
	// ReleaseDeviceAccess releases access to a device
	ReleaseDeviceAccess(ctx context.Context, in *ReleaseDeviceAccessRequest, opts ...grpc.CallOption) (*ReleaseDeviceAccessResponse, error)
	// SubscribeToDevice streams data from a device (server streaming)
	SubscribeToDevice(ctx context.Context, in *SubscribeToDeviceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeviceDataFrame], error)
	// DeviceChannel establishes bidirectional streaming for device control and data
	DeviceChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeviceCommand, DeviceDataFrame], error)
	// WatchDevices streams device state changes (add, remove, state change)
	WatchDevices(ctx context.Context, in *WatchDevicesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeviceEvent], error)
}

type deviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeviceServiceClient(cc grpc.ClientConnInterface) DeviceServiceClient {
	return &deviceServiceClient{cc}
}

func (c *deviceServiceClient) RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterDeviceResponse)
	err := c.cc.Invoke(ctx, DeviceService_RegisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) UnregisterDevice(ctx context.Context, in *UnregisterDeviceRequest, opts ...grpc.CallOption) (*UnregisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterDeviceResponse)
	err := c.cc.Invoke(ctx, DeviceService_UnregisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDevicesResponse)
	err := c.cc.Invoke(ctx, DeviceService_ListDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) GetDevice(ctx context.Context, in *GetDeviceRequest, opts ...grpc.CallOption) (*GetDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeviceResponse)
	err := c.cc.Invoke(ctx, DeviceService_GetDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) RequestDeviceAccess(ctx context.Context, in *RequestDeviceAccessRequest, opts ...grpc.CallOption) (*RequestDeviceAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestDeviceAccessResponse)
	err := c.cc.Invoke(ctx, DeviceService_RequestDeviceAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) ReleaseDeviceAccess(ctx context.Context, in *ReleaseDeviceAccessRequest, opts ...grpc.CallOption) (*ReleaseDeviceAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseDeviceAccessResponse)
	err := c.cc.Invoke(ctx, DeviceService_ReleaseDeviceAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) SubscribeToDevice(ctx context.Context, in *SubscribeToDeviceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeviceDataFrame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeviceService_ServiceDesc.Streams[0], DeviceService_SubscribeToDevice_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToDeviceRequest, DeviceDataFrame]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_SubscribeToDeviceClient = grpc.ServerStreamingClient[DeviceDataFrame]

func (c *deviceServiceClient) DeviceChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeviceCommand, DeviceDataFrame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeviceService_ServiceDesc.Streams[1], DeviceService_DeviceChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeviceCommand, DeviceDataFrame]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_DeviceChannelClient = grpc.BidiStreamingClient[DeviceCommand, DeviceDataFrame]

func (c *deviceServiceClient) WatchDevices(ctx context.Context, in *WatchDevicesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeviceEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeviceService_ServiceDesc.Streams[2], DeviceService_WatchDevices_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchDevicesRequest, DeviceEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_WatchDevicesClient = grpc.ServerStreamingClient[DeviceEvent]

// DeviceServiceServer is the server API for DeviceService service.
// All implementations must embed UnimplementedDeviceServiceServer
// for forward compatibility.
//
// DeviceService provides device registration and access management
type DeviceServiceServer interface {
	// RegisterDevice registers a new device with the system
	RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error)
	// UnregisterDevice removes a device from the system
	UnregisterDevice(context.Context, *UnregisterDeviceRequest) (*UnregisterDeviceResponse, error)
	// ListDevices returns all registered devices, optionally filtered by type
	ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error)
	// GetDevice returns details about a specific device
	GetDevice(context.Context, *GetDeviceRequest) (*GetDeviceResponse, error)
	// RequestDeviceAccess requests access to a device
	RequestDeviceAccess(context.Context, *RequestDeviceAccessRequest) (*RequestDeviceAccessResponse, error)
	// ReleaseDeviceAccess releases access to a device
	ReleaseDeviceAccess(context.Context, *ReleaseDeviceAccessRequest) (*ReleaseDeviceAccessResponse, error)
	// SubscribeToDevice streams data from a device (server streaming)
	SubscribeToDevice(*SubscribeToDeviceRequest, grpc.ServerStreamingServer[DeviceDataFrame]) error
	// DeviceChannel establishes bidirectional streaming for device control and data
	DeviceChannel(grpc.BidiStreamingServer[DeviceCommand, DeviceDataFrame]) error
	// WatchDevices streams device state changes (add, remove, state change)
	WatchDevices(*WatchDevicesRequest, grpc.ServerStreamingServer[DeviceEvent]) error
	mustEmbedUnimplementedDeviceServiceServer()
}

// UnimplementedDeviceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeviceServiceServer struct{}

func (UnimplementedDeviceServiceServer) RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedDeviceServiceServer) UnregisterDevice(context.Context, *UnregisterDeviceRequest) (*UnregisterDeviceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterDevice not implemented")
}
func (UnimplementedDeviceServiceServer) ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDevices not implemented")
}
func (UnimplementedDeviceServiceServer) GetDevice(context.Context, *GetDeviceRequest) (*GetDeviceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDevice not implemented")
}
func (UnimplementedDeviceServiceServer) RequestDeviceAccess(context.Context, *RequestDeviceAccessRequest) (*RequestDeviceAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestDeviceAccess not implemented")
}
func (UnimplementedDeviceServiceServer) ReleaseDeviceAccess(context.Context, *ReleaseDeviceAccessRequest) (*ReleaseDeviceAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReleaseDeviceAccess not implemented")
}
func (UnimplementedDeviceServiceServer) SubscribeToDevice(*SubscribeToDeviceRequest, grpc.ServerStreamingServer[DeviceDataFrame]) error {
	return status.Error(codes.Unimplemented, "method SubscribeToDevice not implemented")
}
func (UnimplementedDeviceServiceServer) DeviceChannel(grpc.BidiStreamingServer[DeviceCommand, DeviceDataFrame]) error {
	return status.Error(codes.Unimplemented, "method DeviceChannel not implemented")
}
func (UnimplementedDeviceServiceServer) WatchDevices(*WatchDevicesRequest, grpc.ServerStreamingServer[DeviceEvent]) error {
	return status.Error(codes.Unimplemented, "method WatchDevices not implemented")
}
func (UnimplementedDeviceServiceServer) mustEmbedUnimplementedDeviceServiceServer() {}
func (UnimplementedDeviceServiceServer) testEmbeddedByValue()                       {}

// UnsafeDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeviceServiceServer will
// result in compilation errors.
type UnsafeDeviceServiceServer interface {
	mustEmbedUnimplementedDeviceServiceServer()
}

func RegisterDeviceServiceServer(s grpc.ServiceRegistrar, srv DeviceServiceServer) {
	// If the following call panics, it indicates UnimplementedDeviceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeviceService_ServiceDesc, srv)
}

func _DeviceService_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_RegisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).RegisterDevice(ctx, req.(*RegisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_UnregisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).UnregisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_UnregisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).UnregisterDevice(ctx, req.(*UnregisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_ListDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDevicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).ListDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_ListDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).ListDevices(ctx, req.(*ListDevicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_GetDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).GetDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_GetDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).GetDevice(ctx, req.(*GetDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_RequestDeviceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDeviceAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).RequestDeviceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_RequestDeviceAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).RequestDeviceAccess(ctx, req.(*RequestDeviceAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_ReleaseDeviceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseDeviceAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).ReleaseDeviceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_ReleaseDeviceAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).ReleaseDeviceAccess(ctx, req.(*ReleaseDeviceAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_SubscribeToDevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToDeviceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceServiceServer).SubscribeToDevice(m, &grpc.GenericServerStream[SubscribeToDeviceRequest, DeviceDataFrame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_SubscribeToDeviceServer = grpc.ServerStreamingServer[DeviceDataFrame]

func _DeviceService_DeviceChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DeviceServiceServer).DeviceChannel(&grpc.GenericServerStream[DeviceCommand, DeviceDataFrame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_DeviceChannelServer = grpc.BidiStreamingServer[DeviceCommand, DeviceDataFrame]

func _DeviceService_WatchDevices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchDevicesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeviceServiceServer).WatchDevices(m, &grpc.GenericServerStream[WatchDevicesRequest, DeviceEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_WatchDevicesServer = grpc.ServerStreamingServer[DeviceEvent]

// DeviceService_ServiceDesc is the grpc.ServiceDesc for DeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "device.v1.DeviceService",
	HandlerType: (*DeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDevice",
			Handler:    _DeviceService_RegisterDevice_Handler,
		},
		{
			MethodName: "UnregisterDevice",
			Handler:    _DeviceService_UnregisterDevice_Handler,
		},
		{
			MethodName: "ListDevices",
			Handler:    _DeviceService_ListDevices_Handler,
		},
		{
			MethodName: "GetDevice",
			Handler:    _DeviceService_GetDevice_Handler,
		},
		{
			MethodName: "RequestDeviceAccess",
			Handler:    _DeviceService_RequestDeviceAccess_Handler,
		},
		{
			MethodName: "ReleaseDeviceAccess",
			Handler:    _DeviceService_ReleaseDeviceAccess_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToDevice",
			Handler:       _DeviceService_SubscribeToDevice_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeviceChannel",
			Handler:       _DeviceService_DeviceChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchDevices",
			Handler:       _DeviceService_WatchDevices_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/proto/device/v1/device.proto",
}
